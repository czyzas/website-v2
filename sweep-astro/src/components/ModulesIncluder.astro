---
import path from 'node:path';
import type { AstroComponentFactory } from 'astro/runtime/server/index.js';
import type {
  ModulesCollectionFragment,
  ModulesModulesContentGatedLayout,
} from '@/__generated__/cms';
import Gated from '@/components/Gated.astro';

type Props = {
  data?: ModulesCollectionFragment;
  /** @default 'default' */
  category?: ModuleCategory;
};
type ModuleCategory = 'all' | 'default' | 'article';
const { data, category = 'default' } = Astro.props;
const modulesContent = data?.modulesContent;

const getCategoryModules = (category: ModuleCategory) => {
  switch (category) {
    case 'all':
      return Astro.glob('../modules/**/*.astro');
    case 'article':
      return Astro.glob('../modules/article/*.astro');
    default:
      return Astro.glob('../modules/*.astro');
  }
};

const modulesComponents = await getCategoryModules(category);
const components: Record<string, AstroComponentFactory> = {};
for (const component of modulesComponents) {
  const componentBaseName = path.parse(component.file).name;

  components[componentBaseName] = component.default;
}

const ungatedComponents: AstroComponentFactory[] = [];
const gatedComponents: AstroComponentFactory[] = [];
let isGated = false;
let gatedInformation: ModulesModulesContentGatedLayout | undefined;
---

{
  !!modulesContent && (
    <Fragment>
      {modulesContent.map((module) => {
        const layoutName = module?.layoutName ?? '';
        if (!layoutName) return null;

        const Component = components?.[layoutName];
        if (!Component) return null;

        if (layoutName === 'gated') {
          isGated = true;
          gatedInformation = module as ModulesModulesContentGatedLayout;
        }
        if (isGated) gatedComponents.push(<Component {...module} />);
        else ungatedComponents.push(<Component {...module} />);

        return null;
      })}
      {ungatedComponents}
      {isGated && <Gated {...gatedInformation}>{gatedComponents}</Gated>}
    </Fragment>
  )
}
