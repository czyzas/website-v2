---
import path from 'node:path';
import type { AstroComponentFactory } from 'astro/runtime/server/index.js';
import type {
  ModulesCollectionFragment,
  ModulesModulesContentGatedLayout,
} from '@/__generated__/cms';
import Gated from '@/components/Gated.astro';
import type { ModuleMeta } from '@/types';

type Props = {
  data?: ModulesCollectionFragment;
  /** @default 'default' */
  category?: ModuleMeta['moduleType'];
};
const { data, category = 'default' } = Astro.props;
const modulesContent = data?.modulesContent;

const modulesComponents = await Astro.glob('../modules/*.astro');
const components: Record<string, AstroComponentFactory> = {};
for (const component of modulesComponents) {
  const componentBaseName = path.parse(component.file).name;

  components[componentBaseName] = component.default;
}

const ungatedComponents: ModulesCollectionFragment[] = [];
const gatedComponents: ModulesCollectionFragment[] = [];
let isGated = false;
let gatedFormName = '';
---

{
  !!modulesContent && (
    <Fragment>
      {modulesContent.map((module, index) => {
        const layoutName = module?.layoutName ?? '';
        if (!layoutName) {
          console.warn(`Module ${module?.__typename} doesn't have layoutName`);
          return null;
        }

        const Component = components?.[layoutName];
        if (!Component) return null;

        const meta: ModuleMeta = {
          index,
          moduleType: category,
        };

        if (layoutName === 'gated') {
          isGated = true;
          gatedFormName =
            (module as ModulesModulesContentGatedLayout).formName ?? '';
        }
        if (isGated)
          gatedComponents.push(<Component __meta__={meta} {...module} />);
        else ungatedComponents.push(<Component __meta__={meta} {...module} />);

        return null;
      })}
      {ungatedComponents}
      {isGated && <Gated formName={gatedFormName}>{gatedComponents}</Gated>}
    </Fragment>
  )
}
